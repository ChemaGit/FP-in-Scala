package collections

object HigherOrderMethods {
	def main(args: Array[String]): Unit = {
		println("*****map*********")
		val nums = List(5,3,2,5,4,6,7)
		val map = nums.map(v => v * 2)
		println(map.mkString(","))
		val map1 = nums.map(v => v * v)
		println(map1.mkString(","))
		val map2 = nums.map(v => v / 2.0)
		println(map2.mkString(","))
		val map3 = nums.map(v => "hi" * v)
		println(map3.mkString(","))
		println("*****filter*****")
		val filter = nums.filter(v => v % 2 == 0)
		println(filter.mkString(","))
		val filter1 = nums.filter(v => v % 2 == 1)
		println(filter1.mkString(","))
		val filter2 = nums.filter(v => v % 2 == 1).map(v => v * 2)
		println(filter2.mkString(","))
		println("*****count*****")
		val count = nums.count(v => v % 2 == 0)
		println(count)
		println("*****dropWhile*****")
		val dropWhile = nums.dropWhile(v => v < 6)
		println(dropWhile.mkString(","))
		val dropWhile1 = nums.dropWhile(v => v > 2)
		println(dropWhile1.mkString(","))
		println("*****exists*****")
		val exists = nums.exists(v => v % 8 == 0)
		println(exists)
		val exists1 = nums.exists(v => v % 4 == 0)
		println(exists1)
		println("*****filterNot*****")
		val filterNot = nums.filterNot(v => v % 2 == 0)
		println(filterNot.mkString(","))
		println("*****flatMap*****")
		val nums2 = nums.map(v => Array.fill(v)(v))
		val flatmap = nums2.flatMap(l => l)
		println(flatmap.mkString(","))
		println("*****forall*****")
		val forall = nums.forall(v => v < 20)
		println(forall)
		val forall1 = nums.forall(v => v < 5)
		println(forall1)
		println("*****foreach*****")
		nums.foreach(println)
		println("*****indexWhere*****")
		val indexWhere = nums.indexWhere(v => v == 7)
		println(indexWhere)
		val indexWhere1 = nums.indexWhere(v => v % 4 == 0)
		println(indexWhere1)
		println("*****lastIndexWhere*****")
		val lastIndexWhere = nums.lastIndexWhere(v => v == 7)
		println(lastIndexWhere)
		val lastIndexWhere1 = nums.lastIndexWhere(v => v % 2 == 0)
		println(lastIndexWhere1)
		println("*****partition*****")
		val partition = nums.partition(v => v % 2 == 0)
		println(partition)
		val (even, odd) = nums.partition(v => v % 2 == 0)
		println(even.mkString(","))
		println(odd.mkString(","))
		println("*****takeWhile*****")
		val takeWhile = nums.takeWhile(v => v % 4 != 0)
		println(takeWhile.mkString(","))
		println("*****dropWhile*****")
		val drop = nums.dropWhile(v => v % 4 != 0)
		println(drop.mkString(","))
	}
}
